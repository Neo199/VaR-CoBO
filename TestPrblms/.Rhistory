source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/Ising/ising_4x4.R")
inst_seed <- 2
# ---------------------------------------------------------
# INITIAL SAMPLES FOR STATISTICAL MODELS
# ---------------------------------------------------------
# Initial samples for training
x_vals <- sample_models(n_init, n_vars)
y_vals <- model(x_vals, theta_P)
print(x_vals)
print(y_vals)
# Find number of iterations based on total budget
n_init <- nrow(x_vals)
n_iter <- evalBudget - n_init
# Train initial statistical model
# setup data for training
xTrain <- x_vals
yTrain <- y_vals
# Generate interaction terms for the input data
xTrain_in_comb <- order_effects(xTrain, order)
xTrain_in <- xTrain_in_comb$xTrain_in
inter_combos <- xTrain_in_comb$combos
cDims <- dim(xTrain_in)
nSamps <- cDims[1]
nCoeffs <- cDims[2]
n <- nrow(xTrain_in)
p <- ncol(xTrain_in)
#Setup dataframe for stan_glm training
X <- xTrain_in
y <- y_vals
#Create a initial dataframe
data <- data.frame(y=y , X)
#Initialise theta values
theta_ini <- rep(0.5, ncol(xTrain))
theta_current <- theta_ini
# browser()
# ---------------------------------------------------------
# RUN PRBOCS
# ---------------------------------------------------------
# Start timing for BOCS-GA
start_time <- Sys.time()
prbocs_result <- prbocs_optim(data, evalBudget, n_iter, n_vars, xTrain, xTrain_in, theta_current, order)
# End timing
end_time <- Sys.time()
prbocs_elapsed_time <- end_time - start_time
prbocsga_result <- prbocs_ga(data, evalBudget, n_iter, n_vars, xTrain, xTrain_in, theta_current, order)
prbocs_vb_result <- prbocs_vb_optim(data, evalBudget, n_iter, n_vars, xTrain, xTrain_in, theta_current, order)
prbocs_vb_ga_result <- prbocs_vb_ga(data, evalBudget, n_iter, n_vars, xTrain, xTrain_in, theta_current, order)
bocsga_result <- bocs_ga(data, evalBudget, n_iter, n_vars, xTrain, xTrain_in, order)
bocssa_result <- bocs_sa(data, evalBudget, n_iter, n_vars, xTrain, xTrain_in, order)
bocssdp_result <- bocs_sdp(data, evalBudget, n_iter, n_vars, xTrain, xTrain_in, order)
ga_model <- function(x) {
x_mat <- matrix(x, nrow = 1)  # convert vector to 1-row matrix
model(x_mat, theta_P)
}
GA_run <- ga(type = "binary", fitness = ga_model, nBits = n_vars,
popSize = 100, maxiter = 1000, run = 100, monitor = FALSE)
ga_result <- list(solution = GA_run@solution, fitness_value = GA_run@fitnessValue)
ga_result
source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/sample_models.R")
source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/Oh_NAS.R")
source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/thompson_svb.R")
source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/ordertheta_interaction.R")
source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/prbocs_vb.R")
library(GA)
library(psych)
library(lpSolve)
library(ompr)
library(ompr.roi)
library(ggplot2)
library(dplyr)
library(ROI)
library(GPfit)
library(rstanarm)
library(rstan)
library(sparsevb)
library(bayesplot)
View(estimateSigma)
# source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/funs.common.R")
# ---------------------------------------------------------
# SET INPUTS
# ---------------------------------------------------------
n_layers <- 3
n_size <- 3
n_vars <- n_layers * n_size
evalBudget <- 100
n_init <- 10
order <- 2
seed <- 1
instances <- 1
torch_manual_seed(1)
View(estimateSigma)
# ---------------------------------------------------------
# DEFINE TRUE MODEL
# ---------------------------------------------------------
data_type <- "MNIST"  # or "FashionMNIST", "CIFAR10", etc.
batch_size <- 32
# Load dataset and get loaders once
loaders <- load_dataset(data_type, batch_size)
# Get dataset info for image channels and sizes
get_dataset_info <- function(data_type) {
if (data_type %in% c("MNIST", "FashionMNIST")) {
list(n_ch_in = 1, h_in = 28, w_in = 28, n_classes = 10)
} else if (data_type == "CIFAR10") {
list(n_ch_in = 3, h_in = 32, w_in = 32, n_classes = 10)
} else {
stop("Unsupported dataset")
}
}
data_info <- get_dataset_info(data_type)
model <- function(x_vals, loaders, data_info) {
scores <- apply(x_vals, 1, function(x)
nas_binary_evaluate(x, loaders, data_info$n_ch_in, data_info$h_in, data_info$w_in, data_info$n_classes)
)
list(loss = scores)
}
for(inst in 1:instances){
starttime <- Sys.time()
set.seed(inst)
browser()
# ---------------------------------------------------------
# INITIAL SAMPLES FOR STATISTICAL MODELS
# ---------------------------------------------------------
x_vals <- sample_models(n_init, n_vars)
y_vals <- model(x_vals, loaders, data_info)
print(x_vals)
print(y_vals$loss)
# ---------------------------------------------------------
# RUN PROCS
# ---------------------------------------------------------
# Find number of iterations based on total budget
n_init <- nrow(x_vals)
n_iter <- evalBudget - n_init
# Train initial statistical model
# setup data for training
xTrain <- x_vals
yTrain <- y_vals$loss
# Generate interaction terms for the input data
xTrain_in_comb <- order_effects(xTrain, order)
xTrain_in <- xTrain_in_comb$xTrain_in
inter_combos <- xTrain_in_comb$combos
cat("xTrain with interaction terms","\n")
print(xTrain_in)
cDims <- dim(xTrain_in)
nSamps <- cDims[1]
nCoeffs <- cDims[2]
# cat("nSamps, nCoeffs", c(nSamps, nCoeffs), "\n")
hs_ss_sd <- sd(xTrain)
n <- nrow(xTrain_in)
p <- ncol(xTrain_in)
#Setup dataframe for stan_glam training
data <- data.frame(y=y_vals$loss , xTrain_in)
prbocs_vb_result <- prbocs_vb_optim(data, evalBudget, n_iter,
n_vars, xTrain, xTrain_in,
theta_current, order)
endtime <- Sys.time()
print("Prbocs vb Instance", inst)
print(prbocs_vb_result)
prbocs_vb_elapsed_time <- starttime - endtime
prbocs_vb <- list(instance_id = inst, prbocs_vb_result = prbocs_vb_result,
time_taken = prbocs_vb_elapsed_time)
}
# ---------------------------------------------------------
# INITIAL SAMPLES FOR STATISTICAL MODELS
# ---------------------------------------------------------
x_vals <- sample_models(n_init, n_vars)
y_vals <- model(x_vals, loaders, data_info)
data_info
source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/sample_models.R")
source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/Oh_NAS.R")
source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/thompson_svb.R")
source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/ordertheta_interaction.R")
source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/prbocs_vb.R")
library(GA)
library(psych)
library(lpSolve)
library(ompr)
library(ompr.roi)
library(ggplot2)
library(dplyr)
library(ROI)
library(GPfit)
library(rstanarm)
library(rstan)
library(sparsevb)
library(bayesplot)
# source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/funs.common.R")
# ---------------------------------------------------------
# SET INPUTS
# ---------------------------------------------------------
n_layers <- 3
n_size <- 3
n_vars <- n_layers * n_size
evalBudget <- 100
n_init <- 10
order <- 2
seed <- 1
instances <- 1
torch_manual_seed(1)
# ---------------------------------------------------------
# DEFINE TRUE MODEL
# ---------------------------------------------------------
data_type <- "CIFAR10"
torch_manual_seed(1)  # global seed if you want
model <- make_nas_model(
data_type   = data_type,
batch_size  = 32,
n_epochs    = 3,
device      = 0,
flop_weight = 0.02,
seed        = 123,        # fixes data splits & init
verbose_each = TRUE       # show per-arch progress
)
inst
set.seed(inst)
# ---------------------------------------------------------
# INITIAL SAMPLES FOR STATISTICAL MODELS
# ---------------------------------------------------------
x_vals <- sample_models(n_init, n_vars)
y_vals <- model(x_vals)
x_vals
print(x_vals)
print(y_vals$loss)
# Find number of iterations based on total budget
n_init <- nrow(x_vals)
n_iter <- evalBudget - n_init
# Train initial statistical model
# setup data for training
xTrain <- x_vals
yTrain <- y_vals$loss
# Generate interaction terms for the input data
xTrain_in_comb <- order_effects(xTrain, order)
xTrain_in <- xTrain_in_comb$xTrain_in
inter_combos <- xTrain_in_comb$combos
cat("xTrain with interaction terms","\n")
print(xTrain_in)
cDims <- dim(xTrain_in)
nSamps <- cDims[1]
nCoeffs <- cDims[2]
hs_ss_sd <- sd(xTrain)
n <- nrow(xTrain_in)
p <- ncol(xTrain_in)
#Setup dataframe for stan_glam training
data <- data.frame(y=y_vals$loss , xTrain_in)
source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/prbocs_vb.R")
prbocs_vb_result <- prbocs_vb_optim(data, evalBudget, n_iter,
n_vars, xTrain, xTrain_in,
theta_current, order)
n
prbocs_vb_result <- prbocs_vb_optim(data, evalBudget, n_iter,
n_vars, xTrain, xTrain_in,
theta_current, order)
data
data_new
y_new$loss
source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/prbocs_vb.R")
prbocs_vb_result <- prbocs_vb_optim(data, evalBudget, n_iter,
n_vars, xTrain, xTrain_in,
theta_current, order)
data_new
warnings()
prbocs_vb_result$solution
prbocs_vb_result$data$y
source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/Oh_NAS.R")
source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/test_NAS.R")
Q
# --- Convert binary array to node_type + adjacency matrix ---
array2network <- function(x, n_nodes) {
node_type <- x[1:(2 * (n_nodes - 2))]
connectivity <- x[(2 * (n_nodes - 2) + 1):length(x)]
adj_mat <- matrix(0, nrow = n_nodes, ncol = n_nodes)
ind <- 1
for (i in 1:n_nodes) {
if (i < n_nodes) {
len <- n_nodes - i
adj_mat[i, (i+1):n_nodes] <- connectivity[ind:(ind + len - 1)]
ind <- ind + len
}
}
adj_mat <- valid_net_topo(adj_mat)
return(list(node_type = node_type, adj_mat = adj_mat))
}
# --- Mimic Python valid_net_topo ---
valid_net_topo <- function(adj_mat) {
n_nodes <- nrow(adj_mat)
# Ensure upper triangular
adj_mat[lower.tri(adj_mat, diag = TRUE)] <- 0
aug_mat_input <- diag(n_nodes)
aug_mat_output <- diag(n_nodes)
dist_input <- rep(NA, n_nodes)
dist_output <- rep(NA, n_nodes)
# Distance from input
for (s in 1:(n_nodes-1)) {
aug_mat_input <- aug_mat_input %*% adj_mat
reachable <- which(aug_mat_input[1, ] > 0)
dist_input[reachable] <- s
}
# Distance to output
for (s in 1:(n_nodes-1)) {
aug_mat_output <- aug_mat_output %*% t(adj_mat)
reachable <- which(aug_mat_output[n_nodes, ] > 0)
dist_output[reachable] <- s
}
# If no path from input to output, return NULL
if (is.na(dist_input[n_nodes]) || is.na(dist_output[1])) {
return(NULL)
}
# Remove nodes not connected from input or to output
for (v in 2:n_nodes) {
if (is.na(dist_input[v])) {
adj_mat[v, ] <- 0
adj_mat[, v] <- 0
}
}
for (v in 1:(n_nodes-1)) {
if (is.na(dist_output[v])) {
adj_mat[v, ] <- 0
adj_mat[, v] <- 0
}
}
return(adj_mat)
}
# --- Example usage ---
set.seed(42)
n_nodes <- 5
# Example binary vector: 2*(n_nodes-2) bits for node_type + rest for connectivity
node_type_bits <- sample(0:1, 2 * (n_nodes - 2), replace = TRUE)
conn_bits <- sample(0:1, (n_nodes * (n_nodes - 1) / 2) - (n_nodes - 1), replace = TRUE)
x <- c(node_type_bits, conn_bits)
network <- array2network(x, n_nodes)
print(network$node_type)
print(network$adj_mat)
network
source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/Oh_NAS.R")
torch_manual_seed(1)  # global seed
model_fn <- make_nas_model(
data_type   = "CIFAR10",
batch_size  = 32,
n_epochs    = 3,
device      = 0,
flop_weight = 0.02,
seed        = 123,        # fixes dataset split & initial weights
verbose_each = TRUE
)
# Example 31-bit binary vector
x <- sample(0:1, 31, replace = TRUE)
model_fn(x)$loss  # evaluate score for this architecture
source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/Oh_NAS.R")
torch_manual_seed(1)  # global seed
model_fn <- make_nas_model(
data_type   = "CIFAR10",
batch_size  = 32,
n_epochs    = 3,
device      = 0,
flop_weight = 0.02,
seed        = 123,        # fixes dataset split & initial weights
verbose_each = TRUE
)
# Example 31-bit binary vector
x <- sample(0:1, 31, replace = TRUE)
model_fn(x)$loss  # evaluate score for this architecture
source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/Oh_NAS.R")
torch_manual_seed(1)  # global seed
model_fn <- make_nas_model(
data_type   = "CIFAR10",
batch_size  = 32,
n_epochs    = 3,
device      = 0,
flop_weight = 0.02,
seed        = 123,        # fixes dataset split & initial weights
verbose_each = TRUE
)
# Example 31-bit binary vector
x <- sample(0:1, 31, replace = TRUE)
model_fn(x)$loss  # evaluate score for this architecture
x
source("~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/Oh_NAS.R")
model_fn <- make_nas_model(
data_type = "CIFAR10",
batch_size = 32,
n_epochs = 3,
device = 0,
flop_weight = 0.02,
seed = 123
)
model_fn(x)
rlang::last_trace()
library(reticulate)
# --- Set Python environment ---
use_python("/usr/local/bin/python3", required = TRUE) # or use_condaenv("myenv")
py_config()  # check Python version & packages
# --- Add COMBO repo to Python path ---
sys <- import("sys")
sys$path <- c(sys$path, "~/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/COMBO")
# --- Import NASBinary module ---
nas_module <- import("NASBinary", convert = FALSE)  # replace NASBinary with filename if different
# --- Import NASBinary module ---
nas_module <- import("nas_binary", convert = FALSE)  # replace NASBinary with filename if different
# --- Import NASBinary module ---
nas_module <- import("nas_binary.py", convert = FALSE)  # replace NASBinary with filename if different
# --- Import NASBinary module ---
nas_module <- import("nas_binary", convert = FALSE)  # replace NASBinary with filename if different
print(sys$path)
sys$path <- c(sys$path, "/Users/niyati/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/COMBO")
print(sys$path)
# --- Import NASBinary module ---
nas_module <- import("nas_binary", convert = FALSE)
library(reticulate)
py_config()
py_install(c("GPUtil", "torch", "numpy", "pthflops"), pip = TRUE)
# --- Import NASBinary module ---
nas_module <- import("nas_binary", convert = FALSE)
library(reticulate)
py_config()
library(reticulate)
# --- Set Python environment ---
use_python("/usr/local/bin/python3", required = TRUE) # or use_condaenv("myenv")
py_config()  # check Python version & packages
py_config()  # check Python version & packages
py_install(c("GPUtil", "torch", "numpy", "pthflops"), pip = TRUE)
#To run the python script from COMBO
#
#
#
library(reticulate)
# Use the reticulate virtual environment
use_virtualenv("~/.virtualenvs/r-reticulate", required = TRUE)
#To run the python script from COMBO
#
#
#
library(reticulate)
# Use the reticulate virtual environment
use_virtualenv("~/.virtualenvs/r-reticulate", required = TRUE)
# Verify
py_config()
# --- Add COMBO repo to Python path ---
sys <- import("sys")
sys$path <- c(sys$path, "/Users/niyati/Projects:Codes/PhD-Compute/R code/TestPrblms/NAS/COMBO")
# --- Import NASBinary module ---
nas_module <- import("nas_binary", convert = FALSE)
reticulate::py_last_error()
#To run the python script from COMBO
#
#
#
library(reticulate)
# Point R to the Conda env
use_condaenv("r-nas", required = TRUE)
# Verify
py_config()
library(reticulate)
py_discover_config()     # clears previous Python configurations
library(reticulate)
py_discover_config()
#To run the python script from COMBO
#
#
#
library(reticulate)
# Use the new arm64 virtualenv
use_virtualenv("~/.virtualenvs/r-nas-arm", required = TRUE)
py_config()  # verify Python path and architecture
#To run the python script from COMBO
#
#
#
# Set environment variable to point to the ARM virtualenv
Sys.setenv(RETICULATE_PYTHON = "~/.virtualenvs/r-nas-arm/bin/python3")
library(reticulate)
py_config()  # verify Python path and architecture
Sys.unsetenv("PYTHONPATH")
#To run the python script from COMBO
#
#
#
# Set environment variable to point to the ARM virtualenv
Sys.setenv(RETICULATE_PYTHON = "~/.virtualenvs/r-nas-arm/bin/python3")
library(reticulate)
py_config()  # verify Python path and architecture
#To run the python script from COMBO
#
#
#
# Set environment variable to point to the ARM virtualenv
Sys.setenv(RETICULATE_PYTHON = "~/.virtualenvs/r-nas-arm/bin/python3")
library(reticulate)
py_config()  # verify Python path and architecture
View(df_opt)
write.csv(dataframe,"~/Projects:Codes/P2Compute/Ideal/ini_res.csv", row.names = FALSE)
write.csv(df_opt,"~/Projects:Codes/P2Compute/Ideal/ini_res.csv", row.names = FALSE)
list(best_x = x_best, best_y = y_best)
#To run the python script from COMBO
#
#
#
# Set environment variable to point to the ARM virtualenv
Sys.setenv(RETICULATE_PYTHON = "~/.virtualenvs/r-nas-arm/bin/python3")
library(reticulate)
py_config()  # verify Python path and architecture
#To run the python script from COMBO
#
#
#
# Set environment variable to point to the ARM virtualenv
Sys.setenv(RETICULATE_PYTHON = "~/.virtualenvs/r-nas-arm/bin/python3")
library(reticulate)
py_config()  # verify Python path and architecture
.Platform$r_arch
R --version
Sys.setenv(RETICULATE_PYTHON = "~/.virtualenvs/r-nas-arm/bin/python3")
library(reticulate)
py_config()  # verify Python path and architecture
